"""
    This provides some thin Uxntal for the memlib (this is needed since Uxn has no user-indexable stack) also any additional uxntal templates
"""

_LICENSE = """ ( This file was generated by the Pyuxncle compiler [https://github.com/CPunch/pyuxncle] )\n\n|10 @Console [ &pad $8 &char $1 &byte $1 &short $2 &string $2 ]"""

_MEMDEFS = "@uxncle [ &heap $2 ]\n@number [ &started $1 ]\n"
_MEMENTRY = ";uxncle-heap .uxncle/heap STZ2\n" # sets the heap pointer to the beginning of our free address space
_MEMLIB = ''.join((
    """@print-decimal
	#00 .number/started STZ
	DUP2 #2710 DIV2 DUP2 ,&digit JSR #2710 MUL2 SUB2
	DUP2 #03e8 DIV2 DUP2 ,&digit JSR #03e8 MUL2 SUB2
	DUP2 #0064 DIV2 DUP2 ,&digit JSR #0064 MUL2 SUB2
	DUP2 #000a DIV2 DUP2 ,&digit JSR #000a MUL2 SUB2
	,&digit JSR
	.number/started LDZ ,&end JCN
	LIT '0 .Console/char DEO
	&end
JMP2r
	&digit
	SWP POP
	DUP .number/started LDZ ORA #02 JCN
	POP JMP2r
	LIT '0 ADD .Console/char DEO
	#01 .number/started STZ
JMP2r\n"""
    "@alloc-uxncle\n", # this subroutine handles allocating memory on the heap, expects the size (short)
        ".uxncle/heap LDZ2\n", # load the heap pointer onto the stack
        "ADD2\n", # add the size
        ".uxncle/heap STZ2\n", # store the new heap pointer
        "JMP2r\n", # return
    "@dealloc-uxncle\n", # this subroutine handles deallocating memory from the heap, expects the size (short)
        ".uxncle/heap LDZ2\n", # load the heap pointer onto the stack
        "SWP2\n", # move the heap pointer behind the size, so when we subtract it'll be heap - size, not size - heap
        "SUB2\n", # sub the size from the address
        ".uxncle/heap STZ2\n", # store the new heap pointer
        "JMP2r\n", #return
    "@peek-uxncle-short\n", # this subroutine handles loading a short from the heap and pushing it onto the stack, expects  the offset (short)
        ".uxncle/heap LDZ2\n", # load the heap pointer onto the stack
        "SWP2\n", # move the heap pointer behind the offset
        "SUB2\n",
        "LDA2\n", # loads the short from the heap onto the stack
        "JMP2r\n", # return
    "@poke-uxncle-short\n", # this subroutine handles popping a short from the stack and saving it into the heap, expects the value (short) and the offset (short)
        ".uxncle/heap LDZ2\n", # load the heap pointer onto the stack
        "SWP2\n", # move the heap pointer behind the offset
        "SUB2\n",
        "STA2\n", # stores the value into the address
        "JMP2r\n", # return
    "@peek-uxncle\n", # this subroutine handles loading a byte from the heap and pushing it onto the stack, expects the offset (short)
        ".uxncle/heap LDZ2\n", # load the heap pointer onto the stack
        "SWP2\n", # move the heap pointer behind the offset
        "SUB2\n",
        "LDA\n", # loads the byte from the heap onto the stack
        "JMP2r\n",
    "@poke-uxncle\n", # this subroutine handles popping a byte from the stack and saving it into the heap, expects the value (byte) and the offset (short)
        ".uxncle/heap LDZ2\n", # load the heap pointer onto the stack
        "SWP2\n", # move the heap pointer behind the offset
        "SUB2\n",
        "STA\n", # stores the value into the address */
        "JMP2r\n", # return
    "@uxncle-heap\n" # marks the location after all of user-code and our thin memory lib
))